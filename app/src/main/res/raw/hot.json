[
    
    {
        "id" : 310538,
        "title" : "iOS 提醒事项+ ，快速的添加提醒事项 / Todos，送几个码。",
        "url" : "http://www.v2ex.com/t/310538",
        "content" : "![]( http://ww4.sinaimg.cn/bmiddle/65e4f1e6gw1f8gd4g0vw3j20yi1pcq96.jpg)\u000D\u000A![]( http://ww1.sinaimg.cn/bmiddle/65e4f1e6gw1f8gd4d1t6qj20yi1pc7ak.jpg)\u000D\u000A![]( http://ww4.sinaimg.cn/bmiddle/65e4f1e6gw1f8gd43q1u1j20yi1pc439.jpg)\u000D\u000A![]( http://ww1.sinaimg.cn/bmiddle/65e4f1e6gw1f8gd41o6juj20yi1pcq9e.jpg)\u000D\u000A\u000D\u000AENW93KANELYK\u000D\u000A\u000D\u000A4F6KTHT4AN9J\u000D\u000A\u000D\u000AK94K6E9KL9WP\u000D\u000A\u000D\u000A7ATYL73YKMXN\u000D\u000A\u000D\u000AFFAXH44XT6JL\u000D\u000A\u000D\u000AJYJN4FT9JF7P\u000D\u000A\u000D\u000AWXPN946YHNFH\u000D\u000A\u000D\u000A7PFH9AHEM3MF\u000D\u000A\u000D\u000AEXAMXXYTJEHX\u000D\u000A\u000D\u000AXAR4RALJ7HXP",
        "content_rendered" : "\u003Cp\u003E\u003Cimg alt\u003D\u0022\u0022 src\u003D\u0022http://ww4.sinaimg.cn/bmiddle/65e4f1e6gw1f8gd4g0vw3j20yi1pcq96.jpg\u0022\u003E\u000A\u003Cimg alt\u003D\u0022\u0022 src\u003D\u0022http://ww1.sinaimg.cn/bmiddle/65e4f1e6gw1f8gd4d1t6qj20yi1pc7ak.jpg\u0022\u003E\u000A\u003Cimg alt\u003D\u0022\u0022 src\u003D\u0022http://ww4.sinaimg.cn/bmiddle/65e4f1e6gw1f8gd43q1u1j20yi1pc439.jpg\u0022\u003E\u000A\u003Cimg alt\u003D\u0022\u0022 src\u003D\u0022http://ww1.sinaimg.cn/bmiddle/65e4f1e6gw1f8gd41o6juj20yi1pcq9e.jpg\u0022\u003E\u003C/p\u003E\u000A\u003Cp\u003EENW93KANELYK\u003C/p\u003E\u000A\u003Cp\u003E4F6KTHT4AN9J\u003C/p\u003E\u000A\u003Cp\u003EK94K6E9KL9WP\u003C/p\u003E\u000A\u003Cp\u003E7ATYL73YKMXN\u003C/p\u003E\u000A\u003Cp\u003EFFAXH44XT6JL\u003C/p\u003E\u000A\u003Cp\u003EJYJN4FT9JF7P\u003C/p\u003E\u000A\u003Cp\u003EWXPN946YHNFH\u003C/p\u003E\u000A\u003Cp\u003E7PFH9AHEM3MF\u003C/p\u003E\u000A\u003Cp\u003EEXAMXXYTJEHX\u003C/p\u003E\u000A\u003Cp\u003EXAR4RALJ7HXP\u003C/p\u003E\u000A",
        "replies" : 53,
        "member" : {
            "id" : 97382,
            "username" : "iAugus",
            "tagline" : "",
            "avatar_mini" : "//cdn.v2ex.co/avatar/f38c/d10d/97382_mini.png?m=1435479803",
            "avatar_normal" : "//cdn.v2ex.co/avatar/f38c/d10d/97382_normal.png?m=1435479803",
            "avatar_large" : "//cdn.v2ex.co/avatar/f38c/d10d/97382_large.png?m=1435479803"
        },
        "node" : {
            "id" : 580,
            "name" : "ios",
            "title" : "iOS",
            "title_alternative" : "iOS",
            "url" : "http://www.v2ex.com/go/ios",
            "topics" : 1023,
            "avatar_mini" : "//cdn.v2ex.co/navatar/069d/3bb0/580_mini.png?m=1442496619",
            "avatar_normal" : "//cdn.v2ex.co/navatar/069d/3bb0/580_normal.png?m=1442496619",
            "avatar_large" : "//cdn.v2ex.co/navatar/069d/3bb0/580_large.png?m=1442496619"
        },
        "created" : 1475573669,
        "last_modified" : 1475573669,
        "last_touched" : 1475580535
    },
    
    {
        "id" : 310468,
        "title" : "高中学历的程序员要取得怎样的成绩才有可能获得 BAT 的面试机会？",
        "url" : "http://www.v2ex.com/t/310468",
        "content" : "\u002D 我是一名培训班出来的 Android 开发人员，已经工作了一段时间，十分想进 BAT  \u000D\u000A\u000D\u000A\u0009给自己规划过各种各样的路线，然而觉得都收效甚微  \u000D\u000A\u000D\u000A\u0009诚心想请教大家，像我这样只有高中学历的程序员，究竟要采取什么样的方法，才能获得 BAT 的面试机会呢?  \u000D\u000A\u002D\u002D\u002D  \u000D\u000A希望大家不吝赐教，先表示感谢  \u000D\u000A\u002D\u002D\u000D\u000A\u000D\u000A\u002D 首先说一下我的理解:  \u000D\u000A\u0009\u002D 我觉得没必要在自考上浪费时间，三本，专科，或者自考这些文凭对于进 BAT 意义都不大，应该都过不了初筛  \u000D\u000A    \u000D\u000A    \u002D 我肯定会尽我所能利用好下班的时间恶补 CS 的各种基本技能（包括但不限于数据结构，算法，编译原理等)  \u000D\u000A\u0009\u002D 打磨自己的业务能力（ Android 的 Application 和 FrameWork 层）\u000D\u000A    \u002D 尽可能地多深入地学习 C ， Java 以及一门脚本语言  \u000D\u000A    \u002D 通过一些非正常的渠道，反编译一些知名公司的 app ，研究学习  \u000D\u000A\u002D\u002D\u002D  \u000D\u000A\u002D 那么，在理想情况下，假设我的硬性能力达标了，限于我的高中学历，应该怎样获得去 BAT 面试的机会呢?  \u000D\u000A我个人设想过几种路线，可是觉得都有瑕疵 \u000D\u000A\u0009\u002D 不停地跳槽，一步步往大一点的公司努力，在履历上丰满自己  \u000D\u000A\u0009\u0009\u002D 这种方案我觉得是可以的，但是我十分喜欢现在的公司，短期内完全没有离开的打算  \u000D\u000A    \u002D 经营 Blog ，写技术向的文章提升知名度  \u000D\u000A\u0009\u0009\u002D 这是我的一个设想，也初步在坚持，但不知收效怎样，我比较喜欢写 Blog ，但我觉得靠写 Blog 就能获得 BAT 面试机会希望渺茫\u000D\u000A\u0009\u002D 写开源库  \u000D\u000A\u0009\u0009\u002D 这也是我的一个设想，工作中自己独立写过很多模块，经常觉得可以抽象出来作为 lib 开源，但是不知道在这个路线坚持会不会有成效，而且写开源库的时间成本确实比较高，如果造的是一些很基本的重复的轮子应该也不会给自己带来什么机会\u000D\u000A\u0009\u002D 多参加线下活动，结识一些大牛  \u000D\u000A    \u0009\u002D 本人确实不善社交，这条路对于我来说太难了，自己的公司也是偏业务比较重，所以同事也没法带给我什么好的机会  \u000D\u000A\u002D\u002D\u002D\u000D\u000A\u002D 这是我最近很长一段时间设想的一点想法，诚心的请教大家有没有什么更好的途径  \u000D\u000A\u002D 也想知道我想的这几条路线哪个更实际一点  \u000D\u000A\u002D 我提的这个问题并没有涉及具体的技术细节，现在的我肯定技术上远远达不到 BAT 的标准  \u000D\u000A\u002D 我只是想知道  \u000D\u000A\u0009\u002D 假设，仅仅是假设我的技术达标的情况下，怎么拿到大公司的面试机会\u000D\u000A    \u002D 为自己树立一个正确的方向，避免在一些收益较小的地方浪费时间  \u000D\u000A\u002D\u002D\u002D\u000D\u000A十分诚恳地地向大家请教，再次感谢大家，希望大家不吝赐教!\u000D\u000A\u002D\u002D",
        "content_rendered" : "\u003Cul\u003E\u000A\u003Cli\u003E\u000A\u003Cp\u003E我是一名培训班出来的 Android 开发人员，已经工作了一段时间，十分想进 BAT\u003C/p\u003E\u000A\u003Cp\u003E给自己规划过各种各样的路线，然而觉得都收效甚微\u003C/p\u003E\u000A\u003Cp\u003E诚心想请教大家，像我这样只有高中学历的程序员，究竟要采取什么样的方法，才能获得 BAT 的面试机会呢?\u003C/p\u003E\u000A\u003C/li\u003E\u000A\u003C/ul\u003E\u000A\u003Chr\u003E\u000A\u003Ch2\u003E希望大家不吝赐教，先表示感谢\u003C/h2\u003E\u000A\u003Cul\u003E\u000A\u003Cli\u003E首先说一下我的理解:\u000A\u003Cul\u003E\u000A\u003Cli\u003E\u000A\u003Cp\u003E我觉得没必要在自考上浪费时间，三本，专科，或者自考这些文凭对于进 BAT 意义都不大，应该都过不了初筛\u003C/p\u003E\u000A\u003C/li\u003E\u000A\u003Cli\u003E\u000A\u003Cp\u003E我肯定会尽我所能利用好下班的时间恶补 CS 的各种基本技能（包括但不限于数据结构，算法，编译原理等)\u003C/p\u003E\u000A\u003C/li\u003E\u000A\u003Cli\u003E\u000A\u003Cp\u003E打磨自己的业务能力（ Android 的 Application 和 FrameWork 层）\u003C/p\u003E\u000A\u003C/li\u003E\u000A\u003Cli\u003E\u000A\u003Cp\u003E尽可能地多深入地学习 C ， Java 以及一门脚本语言\u003C/p\u003E\u000A\u003C/li\u003E\u000A\u003Cli\u003E\u000A\u003Cp\u003E通过一些非正常的渠道，反编译一些知名公司的 app ，研究学习\u003C/p\u003E\u000A\u003C/li\u003E\u000A\u003C/ul\u003E\u000A\u003C/li\u003E\u000A\u003C/ul\u003E\u000A\u003Chr\u003E\u000A\u003Cul\u003E\u000A\u003Cli\u003E那么，在理想情况下，假设我的硬性能力达标了，限于我的高中学历，应该怎样获得去 BAT 面试的机会呢?\u003Cbr\u003E\u000A我个人设想过几种路线，可是觉得都有瑕疵\u000A\u003Cul\u003E\u000A\u003Cli\u003E不停地跳槽，一步步往大一点的公司努力，在履历上丰满自己\u000A\u003Cul\u003E\u000A\u003Cli\u003E这种方案我觉得是可以的，但是我十分喜欢现在的公司，短期内完全没有离开的打算\u003C/li\u003E\u000A\u003C/ul\u003E\u000A\u003C/li\u003E\u000A\u003Cli\u003E经营 Blog ，写技术向的文章提升知名度\u000A\u003Cul\u003E\u000A\u003Cli\u003E这是我的一个设想，也初步在坚持，但不知收效怎样，我比较喜欢写 Blog ，但我觉得靠写 Blog 就能获得 BAT 面试机会希望渺茫\u003C/li\u003E\u000A\u003C/ul\u003E\u000A\u003C/li\u003E\u000A\u003Cli\u003E写开源库\u000A\u003Cul\u003E\u000A\u003Cli\u003E这也是我的一个设想，工作中自己独立写过很多模块，经常觉得可以抽象出来作为 lib 开源，但是不知道在这个路线坚持会不会有成效，而且写开源库的时间成本确实比较高，如果造的是一些很基本的重复的轮子应该也不会给自己带来什么机会\u003C/li\u003E\u000A\u003C/ul\u003E\u000A\u003C/li\u003E\u000A\u003Cli\u003E多参加线下活动，结识一些大牛\u000A\u003Cul\u003E\u000A\u003Cli\u003E本人确实不善社交，这条路对于我来说太难了，自己的公司也是偏业务比较重，所以同事也没法带给我什么好的机会\u003C/li\u003E\u000A\u003C/ul\u003E\u000A\u003C/li\u003E\u000A\u003C/ul\u003E\u000A\u003C/li\u003E\u000A\u003C/ul\u003E\u000A\u003Chr\u003E\u000A\u003Cul\u003E\u000A\u003Cli\u003E这是我最近很长一段时间设想的一点想法，诚心的请教大家有没有什么更好的途径\u003C/li\u003E\u000A\u003Cli\u003E也想知道我想的这几条路线哪个更实际一点\u003C/li\u003E\u000A\u003Cli\u003E我提的这个问题并没有涉及具体的技术细节，现在的我肯定技术上远远达不到 BAT 的标准\u003C/li\u003E\u000A\u003Cli\u003E我只是想知道\u000A\u003Cul\u003E\u000A\u003Cli\u003E假设，仅仅是假设我的技术达标的情况下，怎么拿到大公司的面试机会\u003C/li\u003E\u000A\u003Cli\u003E为自己树立一个正确的方向，避免在一些收益较小的地方浪费时间\u003C/li\u003E\u000A\u003C/ul\u003E\u000A\u003C/li\u003E\u000A\u003C/ul\u003E\u000A\u003Chr\u003E\u000A\u003Ch2\u003E十分诚恳地地向大家请教，再次感谢大家，希望大家不吝赐教!\u003C/h2\u003E\u000A",
        "replies" : 47,
        "member" : {
            "id" : 189086,
            "username" : "retarlyn",
            "tagline" : "",
            "avatar_mini" : "//cdn.v2ex.co/gravatar/f9eddebc59df290bd5991861b8ff8416?s=24&d=retro",
            "avatar_normal" : "//cdn.v2ex.co/gravatar/f9eddebc59df290bd5991861b8ff8416?s=48&d=retro",
            "avatar_large" : "//cdn.v2ex.co/gravatar/f9eddebc59df290bd5991861b8ff8416?s=73&d=retro"
        },
        "node" : {
            "id" : 12,
            "name" : "qna",
            "title" : "问与答",
            "title_alternative" : "Questions and Answers",
            "url" : "http://www.v2ex.com/go/qna",
            "topics" : 76691,
            "avatar_mini" : "//cdn.v2ex.co/navatar/c20a/d4d7/12_mini.png?m=1474854765",
            "avatar_normal" : "//cdn.v2ex.co/navatar/c20a/d4d7/12_normal.png?m=1474854765",
            "avatar_large" : "//cdn.v2ex.co/navatar/c20a/d4d7/12_large.png?m=1474854765"
        },
        "created" : 1475537318,
        "last_modified" : 1475537318,
        "last_touched" : 1475580033
    },
    
    {
        "id" : 310457,
        "title" : "我也中招了",
        "url" : "http://www.v2ex.com/t/310457",
        "content" : "开源的数独游戏被克隆上架 AppStore ，并植入广告\u000D\u000A\u000D\u000A**我的版本**\u000D\u000A\u000D\u000A[AppStore]( https://itunes.apple.com/app/id1138612488)\u000D\u000A[应用宝]( http://a.app.qq.com/o/simple.jsp?pkgname\u003Dcom.liteneo.sudoku)\u000D\u000A\u000D\u000A**克隆版本**\u000D\u000A\u000D\u000A[AppStore]( https://itunes.apple.com/app/id1157001386)\u000D\u000A[Google Play]( https://play.google.com/store/apps/details?id\u003Dcom.abbasbourji.sudokutrue)\u000D\u000A\u000D\u000A平时偶尔玩玩数独，就顺手用 React Native 写了个很简单的版本，并开源到了 [Github]( https://github.com/nihgwu/react\u002Dnative\u002Dsudoku)，之前也在这里发过贴 https://www.v2ex.com/t/297842  。然后前几天简单更新了下显得不那么玩具 https://www.v2ex.com/t/310075 \u000D\u000A\u000D\u000A因为这次更新加了多语言支持，就顺手在 AppStore 搜了下 sudoku ，结果发现了这个。基本上就是在我上一个版本的基础上修改了棋盘的颜色，然后把中文换成了英文，还加入了广告，严重影响使用体验，并且把它包装成一个完全自己开发的游戏。作为强迫症患者，最让我不能忍受的是菜单尽然都没对齐，我的英文版就没这个问题╮(╯▽╰)╭\u000D\u000A\u000D\u000A之前也在这里看到有人遇到同样的情况，而且是被克隆了好几份，但是找不到链接了，当时看到这个的时候还是有点想法的，但是为了体现自己的追求，还是毅然选择了 MIT 协议，虽说心理早有准备，但真正遇到这种事情的时候还是很不爽\u000D\u000A\u000D\u000A所以这种事情就只能认栽了吗？",
        "content_rendered" : "\u003Cp\u003E开源的数独游戏被克隆上架 AppStore ，并植入广告\u003C/p\u003E\u000A\u003Cp\u003E\u003Cstrong\u003E我的版本\u003C/strong\u003E\u003C/p\u003E\u000A\u003Cp\u003E\u003Ca href\u003D\u0022https://itunes.apple.com/app/id1138612488\u0022 rel\u003D\u0022nofollow\u0022\u003EAppStore\u003C/a\u003E\u000A\u003Ca href\u003D\u0022http://a.app.qq.com/o/simple.jsp?pkgname\u003Dcom.liteneo.sudoku\u0022 rel\u003D\u0022nofollow\u0022\u003E应用宝\u003C/a\u003E\u003C/p\u003E\u000A\u003Cp\u003E\u003Cstrong\u003E克隆版本\u003C/strong\u003E\u003C/p\u003E\u000A\u003Cp\u003E\u003Ca href\u003D\u0022https://itunes.apple.com/app/id1157001386\u0022 rel\u003D\u0022nofollow\u0022\u003EAppStore\u003C/a\u003E\u000A\u003Ca href\u003D\u0022https://play.google.com/store/apps/details?id\u003Dcom.abbasbourji.sudokutrue\u0022 rel\u003D\u0022nofollow\u0022\u003EGoogle Play\u003C/a\u003E\u003C/p\u003E\u000A\u003Cp\u003E平时偶尔玩玩数独，就顺手用 React Native 写了个很简单的版本，并开源到了 \u003Ca href\u003D\u0022https://github.com/nihgwu/react\u002Dnative\u002Dsudoku\u0022 rel\u003D\u0022nofollow\u0022\u003EGithub\u003C/a\u003E，之前也在这里发过贴 \u003Ca href\u003D\u0022https://www.v2ex.com/t/297842\u0022 rel\u003D\u0022nofollow\u0022\u003Ehttps://www.v2ex.com/t/297842\u003C/a\u003E  。然后前几天简单更新了下显得不那么玩具 \u003Ca href\u003D\u0022https://www.v2ex.com/t/310075\u0022 rel\u003D\u0022nofollow\u0022\u003Ehttps://www.v2ex.com/t/310075\u003C/a\u003E\u003C/p\u003E\u000A\u003Cp\u003E因为这次更新加了多语言支持，就顺手在 AppStore 搜了下 sudoku ，结果发现了这个。基本上就是在我上一个版本的基础上修改了棋盘的颜色，然后把中文换成了英文，还加入了广告，严重影响使用体验，并且把它包装成一个完全自己开发的游戏。作为强迫症患者，最让我不能忍受的是菜单尽然都没对齐，我的英文版就没这个问题╮(╯▽╰)╭\u003C/p\u003E\u000A\u003Cp\u003E之前也在这里看到有人遇到同样的情况，而且是被克隆了好几份，但是找不到链接了，当时看到这个的时候还是有点想法的，但是为了体现自己的追求，还是毅然选择了 MIT 协议，虽说心理早有准备，但真正遇到这种事情的时候还是很不爽\u003C/p\u003E\u000A\u003Cp\u003E所以这种事情就只能认栽了吗？\u003C/p\u003E\u000A",
        "replies" : 38,
        "member" : {
            "id" : 64680,
            "username" : "liteneo",
            "tagline" : "",
            "avatar_mini" : "//cdn.v2ex.co/avatar/0b52/c744/64680_mini.png?m=1417497347",
            "avatar_normal" : "//cdn.v2ex.co/avatar/0b52/c744/64680_normal.png?m=1417497347",
            "avatar_large" : "//cdn.v2ex.co/avatar/0b52/c744/64680_large.png?m=1417497347"
        },
        "node" : {
            "id" : 12,
            "name" : "qna",
            "title" : "问与答",
            "title_alternative" : "Questions and Answers",
            "url" : "http://www.v2ex.com/go/qna",
            "topics" : 76691,
            "avatar_mini" : "//cdn.v2ex.co/navatar/c20a/d4d7/12_mini.png?m=1474854765",
            "avatar_normal" : "//cdn.v2ex.co/navatar/c20a/d4d7/12_normal.png?m=1474854765",
            "avatar_large" : "//cdn.v2ex.co/navatar/c20a/d4d7/12_large.png?m=1474854765"
        },
        "created" : 1475511901,
        "last_modified" : 1475511901,
        "last_touched" : 1475581538
    },
    
    {
        "id" : 310505,
        "title" : "联通：尊敬的用户你好，我是你爹。",
        "url" : "http://www.v2ex.com/t/310505",
        "content" : "大家有没有被联通的上网助手恶心到？你用数据流量上 HTTP 的网站，它立马劫持你的网页给你自作聪明的加了个上网助手的悬浮窗脚本？真的不要太担心\u000D\u000A\u000D\u000A今天打 10010 客服投诉，要求客服关闭我这个功能，客服说她们关闭不了，让我在什么 一起沃 自己关闭。我问了一句：这功能是我打开的吗？你帮我打开经过我同意了吗？客服不语，我说那你把关闭方式发短信过来吧，以下是短信。\u000D\u000A\u000D\u000A尊敬的客户：使用一起沃上网助手自带的关闭功能进行关闭。可以选择本日关闭、本周关闭、或本月关闭（选择本日关闭，一起沃上网助手会在当天隐藏，第二天上网时仍然可见；选择本周关闭，一起沃上网助手会在本周隐藏，下周一开始可见；选择本月关闭，一起沃上网助手会在本月隐藏，下月一号开始可见）。操作步骤：一起沃上网助手界面点击：我的→设置→关闭，来关闭一起沃上网助手。\u000D\u000A广东联通                   \u000D\u000A\u000D\u000A我快速跑了一眼，我问，那我怎么永久关闭？",
        "content_rendered" : "大家有没有被联通的上网助手恶心到？你用数据流量上 HTTP 的网站，它立马劫持你的网页给你自作聪明的加了个上网助手的悬浮窗脚本？真的不要太担心\u000D\u003Cbr /\u003E\u000D\u003Cbr /\u003E今天打 10010 客服投诉，要求客服关闭我这个功能，客服说她们关闭不了，让我在什么 一起沃 自己关闭。我问了一句：这功能是我打开的吗？你帮我打开经过我同意了吗？客服不语，我说那你把关闭方式发短信过来吧，以下是短信。\u000D\u003Cbr /\u003E\u000D\u003Cbr /\u003E尊敬的客户：使用一起沃上网助手自带的关闭功能进行关闭。可以选择本日关闭、本周关闭、或本月关闭（选择本日关闭，一起沃上网助手会在当天隐藏，第二天上网时仍然可见；选择本周关闭，一起沃上网助手会在本周隐藏，下周一开始可见；选择本月关闭，一起沃上网助手会在本月隐藏，下月一号开始可见）。操作步骤：一起沃上网助手界面点击：我的→设置→关闭，来关闭一起沃上网助手。\u000D\u003Cbr /\u003E广东联通                   \u000D\u003Cbr /\u003E\u000D\u003Cbr /\u003E我快速跑了一眼，我问，那我怎么永久关闭？",
        "replies" : 36,
        "member" : {
            "id" : 49380,
            "username" : "usedname",
            "tagline" : "",
            "avatar_mini" : "//cdn.v2ex.co/avatar/c562/02b6/49380_mini.png?m=1398661109",
            "avatar_normal" : "//cdn.v2ex.co/avatar/c562/02b6/49380_normal.png?m=1398661109",
            "avatar_large" : "//cdn.v2ex.co/avatar/c562/02b6/49380_large.png?m=1398661109"
        },
        "node" : {
            "id" : 16,
            "name" : "share",
            "title" : "分享发现",
            "title_alternative" : "Share",
            "url" : "http://www.v2ex.com/go/share",
            "topics" : 20332,
            "avatar_mini" : "//cdn.v2ex.co/navatar/c74d/97b0/16_mini.png?m=1475028071",
            "avatar_normal" : "//cdn.v2ex.co/navatar/c74d/97b0/16_normal.png?m=1475028071",
            "avatar_large" : "//cdn.v2ex.co/navatar/c74d/97b0/16_large.png?m=1475028071"
        },
        "created" : 1475560704,
        "last_modified" : 1475560704,
        "last_touched" : 1475581520
    },
    
    {
        "id" : 310474,
        "title" : "Nexus 6 的 Android 7.0 终于来了",
        "url" : "http://www.v2ex.com/t/310474",
        "content" : "https://developers.google.com/android/nexus/ota#shamu",
        "content_rendered" : "\u003Cp\u003E\u003Ca href\u003D\u0022https://developers.google.com/android/nexus/ota#shamu\u0022 rel\u003D\u0022nofollow\u0022\u003Ehttps://developers.google.com/android/nexus/ota#shamu\u003C/a\u003E\u003C/p\u003E\u000A",
        "replies" : 35,
        "member" : {
            "id" : 80855,
            "username" : "mchl",
            "tagline" : "",
            "avatar_mini" : "//cdn.v2ex.co/gravatar/96ddf6d43773afbdb8be11a73cd6f2d7?s=24&d=retro",
            "avatar_normal" : "//cdn.v2ex.co/gravatar/96ddf6d43773afbdb8be11a73cd6f2d7?s=48&d=retro",
            "avatar_large" : "//cdn.v2ex.co/gravatar/96ddf6d43773afbdb8be11a73cd6f2d7?s=73&d=retro"
        },
        "node" : {
            "id" : 39,
            "name" : "android",
            "title" : "Android",
            "title_alternative" : "Android",
            "url" : "http://www.v2ex.com/go/android",
            "topics" : 3163,
            "avatar_mini" : "//cdn.v2ex.co/navatar/d67d/8ab4/39_mini.png?m=1474945102",
            "avatar_normal" : "//cdn.v2ex.co/navatar/d67d/8ab4/39_normal.png?m=1474945102",
            "avatar_large" : "//cdn.v2ex.co/navatar/d67d/8ab4/39_large.png?m=1474945102"
        },
        "created" : 1475543750,
        "last_modified" : 1475543750,
        "last_touched" : 1475582161
    },
    
    {
        "id" : 310522,
        "title" : "纠结于语言的选择，犹豫在编程路口，求打醒",
        "url" : "http://www.v2ex.com/t/310522",
        "content" : "学过 C#，进度大概在学完面向对象那一层面，自己做过 5\u002D6 个 winform 软件，都是给公司内部用的一些提升工作效率的小玩意儿。看到又有很多人喷 C#低端。。。\u000D\u000A想学 android ，得先学 java 。但是看到网上各种语言阵营撕逼说 java 效率低，好吧，低不低不知道，又觉得现在学 java 也只能用在 android 上了。。。好吧，别和我说用 C#开发 android 的 Xamarin ，这玩意儿先普及起来再说吧。\u000D\u000A想学 web ， html+css 已经没问题，就差 js 和 php 了……\u000D\u000A真的想静下心来好好学精一门语言，实在不知道取舍，对这个圈子也不是很了解，有没有前辈指引一下的。",
        "content_rendered" : "学过 C#，进度大概在学完面向对象那一层面，自己做过 5\u002D6 个 winform 软件，都是给公司内部用的一些提升工作效率的小玩意儿。看到又有很多人喷 C#低端。。。\u000D\u003Cbr /\u003E想学 android ，得先学 java 。但是看到网上各种语言阵营撕逼说 java 效率低，好吧，低不低不知道，又觉得现在学 java 也只能用在 android 上了。。。好吧，别和我说用 C#开发 android 的 Xamarin ，这玩意儿先普及起来再说吧。\u000D\u003Cbr /\u003E想学 web ， html+css 已经没问题，就差 js 和 php 了……\u000D\u003Cbr /\u003E真的想静下心来好好学精一门语言，实在不知道取舍，对这个圈子也不是很了解，有没有前辈指引一下的。",
        "replies" : 31,
        "member" : {
            "id" : 194403,
            "username" : "Famio",
            "tagline" : "天道酬勤",
            "avatar_mini" : "//cdn.v2ex.co/avatar/3a24/b83b/194403_mini.png?m=1475421193",
            "avatar_normal" : "//cdn.v2ex.co/avatar/3a24/b83b/194403_normal.png?m=1475421193",
            "avatar_large" : "//cdn.v2ex.co/avatar/3a24/b83b/194403_large.png?m=1475421193"
        },
        "node" : {
            "id" : 300,
            "name" : "programmer",
            "title" : "程序员",
            "title_alternative" : "Programmer",
            "url" : "http://www.v2ex.com/go/programmer",
            "topics" : 13380,
            "avatar_mini" : "//cdn.v2ex.co/navatar/94f6/d7e0/300_mini.png?m=1475028013",
            "avatar_normal" : "//cdn.v2ex.co/navatar/94f6/d7e0/300_normal.png?m=1475028013",
            "avatar_large" : "//cdn.v2ex.co/navatar/94f6/d7e0/300_large.png?m=1475028013"
        },
        "created" : 1475567258,
        "last_modified" : 1475567258,
        "last_touched" : 1475580117
    },
    
    {
        "id" : 310433,
        "title" : "国庆撸了一篇文章， Git 的核心概念，望 V 友大神们指正",
        "url" : "http://www.v2ex.com/t/310433",
        "content" : "[原文地址]( https://lufficc.com/blog/the\u002Dcore\u002Dconception\u002Dof\u002Dgit)\u000D\u000A\u000D\u000A\u003E 文章内容来自自己的理解 和 https://git\u002Dscm.com/book/en/v2 。转载必须注明出处。\u000D\u000A\u000D\u000A**本文不是 Git 使用教学篇，而是偏向理论方面，旨在更加深刻的理解 Git ，这样才能更好的使用它，让工具成为我们得力的助手。**\u000D\u000A## 版本控制系统\u000D\u000A\u002D\u002D\u002D\u002D\u002D\u002D\u002D\u002D\u002D\u002D\u002D\u002D\u002D\u000D\u000A\u000D\u000AGit 是目前世界上最优秀的分布式版本控制系统。版本控制系统是能够随着时间的推进记录一系列文件的变化以便于你以后想要的退回到某个版本的系统。版本控制系统分为三大类：本地版本控制系统，集中式版本控制系统和分布式版本控制系统\u000D\u000A\u000D\u000A本地版本控制（ Local Version Control Systems ）是将文件的各个版本以一定的数据格式存储在本地的磁盘（有的 VCS 是保存文件的变化补丁，即在文件内容变化时计算出差量保存起来），这种方式在一定程度上解决了手动复制粘贴的问题，但无法解决多人协作的问题。\u000D\u000A\u000D\u000A本地版本控制\u000D\u000A![file]( https://static.lufficc.com/image/cd558122189f264c90636f46c5b97bce.png)\u000D\u000A\u000D\u000A集中式版本控制（ Centralized Version Control Systems ）相比本地版本控制没有什么本质的变化，只是多了个一个中央服务器，各个版本的数据库存储在中央服务器，管理员可以控制开发人员的权限，而开发人员也可以从中央服务器拉取数据。集中式版本控制虽然解决了团队协作问题，但缺点也很明显：所有数据存储在中央服务器，服务器一旦宕机或者磁盘损坏，会造成不可估量的损失。\u000D\u000A\u000D\u000A集中式版本控制\u000D\u000A![file]( https://static.lufficc.com/image/150909dba84d774ff367e96633bb3a90.png)\u000D\u000A\u000D\u000A\u000D\u000A\u000D\u000A分布式版本控制（ Distributed Version Control System ）与前两者均不同。首先，在分布式版本控制系统中，像 Git ， Mercurial ， Bazaar 以及 Darcs 等，系统保存的的不是文件变化的差量，而是文件的快照，即把文件的整体复制下来保存，而不关心具体的变化内容。其次，最重要的是分布式版本控制系统是分布式的，当你从中央服务器拷贝下来代码时，你拷贝的是一个完整的版本库，包括历史纪录，提交记录等，这样即使某一台机器宕机也能找到文件的完整备份。\u000D\u000A\u000D\u000A分布式版本控制\u000D\u000A![file]( https://static.lufficc.com/image/8b98633e172b406026a6b18127160928.png)\u000D\u000A\u000D\u000A## Git 基础\u000D\u000A\u002D\u002D\u002D\u002D\u002D\u002D\u002D\u002D\u002D\u002D\u002D\u002D\u002D\u002D\u002D\u002D\u002D\u002D\u002D\u002D\u002D\u002D\u002D\u002D\u000D\u000AGit 是一个分布式版本控制系统，保存的是文件的完整快照，而不是差异变化或者文件补丁。\u000D\u000A\u000D\u000A保存每一次变化文件的完整内容\u000D\u000A![file]( https://static.lufficc.com/image/a25948ea6ad62bc5f32c0f3473a26a82.png)\u000D\u000A\u000D\u000AGit 每一次提交都是对项目文件的一个完整拷贝，因此你可以完全恢复到以前的任一个提交而不会发生任何区别。这里有一个问题：如果我的项目大小是 10M ，那 Git 占用的空间是不是随着提交次数的增加线性增加呢？我提交（ commit ）了 10 次，占用空间是不是 100M 呢？很显然不是， Git 是很智能的，如果文件没有变化，它只会保存一个指向上一个版本的文件的`指针`，即，对于一个特定版本的文件， Git 只会保存一个副本，但可以有多个指向该文件的`指针`。\u000D\u000A\u000D\u000A未变化的文件只保存上一个版本的指针\u000D\u000A![file]( https://static.lufficc.com/image/6ea58fd87fb479921752c3780c042f28.png)\u000D\u000A\u000D\u000A\u000D\u000AGit 工程有三个工作区域：工作目录，暂存区域，以及本地仓库。工作目录是你当前进行工作的区域；暂存区域是你运行`git add`命令后文件保存的区域，也是下次提交将要保存的文件（注意： Git 提交实际读取的是暂存区域的内容，而与工作区域的文件无关，这也是当你修改了文件之后，如果没有添加`git add`到暂存区域，并不会保存到版本库的原因）；本地仓库就是版本库，记录了你工程某次提交的完整状态和内容，这意味着你的数据永远不会丢失。\u000D\u000A![file]( https://static.lufficc.com/image/c27143ae881ce36f097ba89bbacae972.png)\u000D\u000A相应的，文件也有三种状态：已提交（ committed ），已修改（ modified ）和已暂存（ staged ）。已提交表示该文件已经被安全地保存在本地版本库中了；已修改表示修改了某个文件，但还没有提交保存；已暂存表示把已修改的文件放在下次提交时要保存的清单中，即暂存区域。所以使用 Git 的基本工作流程就是：\u000D\u000A1. 在工作区域增加，删除或者修改文件。\u000D\u000A2. 运行`git add`，将文件快照保存到暂存区域。\u000D\u000A3. 提交更新，将文件永久版保存到版本库中。\u000D\u000A![file]( https://static.lufficc.com/image/c8e38594228844c944ec68fcb82b9152.png)\u000D\u000A\u000D\u000A## Git 对象\u000D\u000A\u002D\u002D\u002D\u002D\u002D\u002D\u002D\u002D\u002D\u002D\u002D\u002D\u002D\u002D\u002D\u002D\u002D\u002D\u002D\u002D\u002D\u002D\u002D\u000D\u000A\u000D\u000A现在已经明白 Git 的基本流程，但 Git 是怎么完成的呢？ Git 怎么区分文件是否发生变化？下面简单介绍一下 Git 的基本原理。\u000D\u000A\u000D\u000A#### SHA\u002D1 校验和\u000D\u000AGit 是一套内容寻址文件系统。意思就是 Git 从核心上来看不过是简单地存储键值对（`key\u002Dvalue`），`value`是文件的内容，而`key`是文件内容与文件头信息的 40 个字符长度的 SHA\u002D1 校验和，例如：`5453545dccd33565a585ffe5f53fda3e067b84d8`。 Git 使用该校验和不是为了加密，而是为了数据的完整性，它可以保证，在很多年后，你重新 checkout 某个 commit 时，一定是它多年前的当时的状态，完全一摸一样。当你对文件进行了哪怕一丁点儿的修改，也会计算出完全不同的 SHA\u002D1 校验和，这种现象叫做“雪崩效应”（ Avalanche effect ）。\u000D\u000A\u000D\u000ASHA\u002D1 校验和因此就是上文提到的文件的`指针`，这和 C 语言中的`指针`很有些不同： C 语言将数据在内存中的地址作为`指针`， Git 将文件的 SHA\u002D1 校验和作为`指针`，目的都是为了唯一区分不同的对象。但是当 C 语言`指针`指向的内存中的内容发生变化时，`指针`并不发生变化，但 Git`指针`指向的文件内容发生变化时，`指针`也会发生变化。所以， Git 中每一个版本的文件，都有一个唯一的`指针`指向它。\u000D\u000A\u000D\u000A#### 文件(blob)对象，树(tree)对象，提交(commit)对象\u000D\u000A\u000D\u000A`blob` 对象保存的仅仅是文件的内容，`tree` 对象更像是操作系统中的文件夹，它可以保存`blob`对象和`tree` 对象。一个单独的 `tree` 对象包含一条或多条 `tree` 记录，每一条记录含有一个指向 `blob` 对象或子 `tree` 对象的 SHA\u002D1 指针，并附有该对象的权限模式 (mode)、类型和文件名信息等：\u000D\u000A![file]( https://static.lufficc.com/image/8f108375134643622b7e9273520eed91.png)\u000D\u000A当你对文件进行修改并提交时，变化的文件会生成一个新的`blob`对象，记录文件的完整内容（是全部内容，不是变化内容），然后针对该文件有一个唯一的 SHA\u002D1 校验和，修改此次提交该文件的`指针`为该 SHA\u002D1 校验和，而对于没有变化的文件，简单拷贝上一次版本的`指针`即 SHA\u002D1 校验和，而不会生成一个全新的`blob`对象，这也解释了 10M 大小的项目进行 10 次提交总大小远远小于 100M 的原因。\u000D\u000A\u000D\u000A另外，每次提交可能不仅仅只有一个 `tree` 对象，它们指明了项目的不同快照，但你必须记住所有对象的 SHA\u002D1 校验和才能获得完整的快照，而且没有作者，何时，为什么保存这些快照的原因。`commit`对象就是问了解决这些问题诞生的，`commit` 对象的格式很简单：指明了该时间点项目快照的顶层`tree`对象、作者 /提交者信息（从 Git 设置的 user.name 和 user.email 中获得)以及当前时间戳、一个空行，上一次的提交对象的 ID 以及提交注释信息。你可以简单的运行`git log`来获取这新信息：\u000D\u000A```\u000D\u000A$ git log\u000D\u000Acommit 2cb0bb475c34a48957d18f67d0623e3304a26489\u000D\u000AAuthor: lufficc \u003Cluffy.lcc@gmail.com\u003E\u000D\u000ADate:   Sun Oct 2 17:29:30 2016 +0800\u000D\u000A\u000D\u000A    fix some font size\u000D\u000A\u000D\u000Acommit f0c8b4b31735b5e5e96e456f9b0c8d5fc7a3e68a\u000D\u000AAuthor: lufficc \u003Cluffy.lcc@gmail.com\u003E\u000D\u000ADate:   Sat Oct 1 02:55:48 2016 +0800\u000D\u000A\u000D\u000A    fix post show css\u000D\u000A\u000D\u000A***********省略***********\u000D\u000A```\u000D\u000A![file]( https://static.lufficc.com/image/092c08d87d63ff0a804356705ce01c4b.png)\u000D\u000A上图的 Test.txt 是第一次提交之前生成的，第一次它的初始 SHA\u002D1 校验和以`3c4e9c`开头。随后对它进行了修改，所以第二次提交时生成了一个全新`blob`对象，校验和以`1f7a7a`开头。而第三次提交时 Test.txt 并没有变化，所以只是保存最近版本的 SHA\u002D1 校验和而不生成全新的`blob`对象。在项目开发过程中新增加的文件在提交后都会生成一个全新的`blob`对象来保存它。**注意除了第一次每个提交对象都有一个指向上一次提交对象的指针**。\u000D\u000A\u000D\u000A因此简单来说，`blob`对象保存文件的内容；`tree`对象类似文件夹，保存`blob`对象和其它`tree`对象；`commit`对象保存`tree`对象，提交信息，作者，邮箱以及上一次的提交对象的 ID （第一次提交没有）。而 Git 就是通过组织和管理这些对象的状态以及复杂的关系实现的版本控制以及以及其他功能如分支。\u000D\u000A\u000D\u000A\u000D\u000A## Git 引用\u000D\u000A\u002D\u002D\u002D\u002D\u002D\u002D\u002D\u002D\u002D\u002D\u002D\u002D\u002D\u002D\u002D\u002D\u002D\u002D\u002D\u002D\u002D\u002D\u002D\u000D\u000A现在再来看引用，就会很简单了。如果我们想要看某个提交记录之前的完整历史，就必须记住这个提交 ID ，但提交 ID 是一个 40 位的 SHA\u002D1 校验和，难记。所以引用就是 SHA\u002D1 校验和的别名，存储在`.git/refs`文件夹中。\u000D\u000A\u000D\u000A最常见的引用也许就是`master`了，因为这是 Git 默认创建的（可以修改，但一般不修改），它始终指向你项目主分支的最后最后一次提交记录。如果在项目根目录运行`cat .git/refs/heads`，会输出一个 SHA\u002D1 校验和，例如：\u000D\u000A```\u000D\u000A$ cat .git/refs/heads/master\u000D\u000A4f3e6a6f8c62bde818b4b3d12c8cf3af45d6dc00\u000D\u000A```\u000D\u000A因此`master`只是一个 40 位 SHA\u002D1 校验和的别名罢了。\u000D\u000A\u000D\u000A还有一个问题， Git 如何知道你当前分支的最后一次的提交 ID?在`.git`文件夹下有一个`HEAD`文件，像这样：\u000D\u000A```\u000D\u000A$ cat .git/HEAD\u000D\u000Aref: refs/heads/master\u000D\u000A```\u000D\u000A`HEAD`文件其实并不包含 SHA\u002D1 值，而是一个指向当前分支的引用，内容会随着切换分支而变化，内容格式像这样：`ref: refs/heads/\u003Cbranch\u002Dname\u003E`。当你执行` git commit `命令时，它就创建了一个` commit `对象，把这个` commit `对象的父级设置为 `HEAD` 指向的引用的 SHA\u002D1 值。\u000D\u000A\u000D\u000A再来说说 Git 的 tag ，标签。标签从某种意义上像是一个引用， 它指向一个 `commit` 对象而不是一个 `tree`，包含一个标签，一组数据，一个消息和一个`commit` 对象的指针。但是区别就是引用随着项目进行它的值在不断向前推进变化，但是标签不会变化——永远指向同一个 `commit`，仅仅是提供一个更加友好的名字。\u000D\u000A\u000D\u000A## Git 分支\u000D\u000A\u002D\u002D\u002D\u002D\u002D\u002D\u002D\u002D\u002D\u002D\u002D\u002D\u002D\u002D\u002D\u002D\u002D\u000D\u000A#### 分支\u000D\u000A\u000D\u000A分支是 Git 的杀手级特征，而且 Git 鼓励在工作流程中频繁使用分支与合并，哪怕一天之内进行许多次都没有关系。因为 Git 分支非常轻量级，不像其他的版本控制，创建分支意味着要把项目完整的拷贝一份，而 Git 创建分支是在瞬间完成的，而与你工程的复杂程度无关。\u000D\u000A\u000D\u000A因为在上文中已经说到， Git 保存文件的最基本的对象是`blob`对象， Git 本质上只是一棵巨大的文件树，树的每一个节点就是`blob`对象，而分支只是树的一个分叉。说白了，分支就是一个有名字的引用，它包含一个提交对象的的 40 位校验和，所以创建分支就是向一个文件写入 41 个字节（外加一个换行符）那么简单，所以自然就快了，而且与项目的复杂程度无关。\u000D\u000A\u000D\u000AGit 的默认分支是 master ，存储在`.git\u005Crefs\u005Cheads\u005Cmaster`文件中，假设你在 master 分支运行`git branch dev`创建了一个名字为`dev`的分支，那么 git 所做的实际操作是：\u000D\u000A1. 在`.git\u005Crefs\u005Cheads`文件夹下新建一个文件名为`dev`（没有扩展名）的文本文件。\u000D\u000A2. 将 HEAD 指向的当前分支（当前为`master`）的 40 位 SHA\u002D1 校验和外加一个换行符写入`dev`文件。\u000D\u000A3. 结束。\u000D\u000A\u000D\u000A![file]( https://static.lufficc.com/image/f6ae8c281b6e8a17f11b2807a97c5109.png)\u000D\u000A\u000D\u000A创建分支就是这么简单，那么切换分支呢？更简单：\u000D\u000A\u000D\u000A1. 修改`.git`文件下的`HEAD`文件为`ref: refs/heads/\u003C分支名称\u003E`。\u000D\u000A2. 按照分支指向的提交记录将工作区的文件恢复至一模一样。\u000D\u000A3. 结束。\u000D\u000A\u000D\u000A记住，`HEAD`文件指向当前分支的最后一次提交，同时，它也是以当前分支再次创建一个分支时，将要写入的内容。\u000D\u000A\u000D\u000A#### 分支合并\u000D\u000A\u000D\u000A再来说一说合并，首先是 Fast\u002Dforward ，换句话说，如果顺着一个分支走下去可以到达另一个分支的话，那么 Git 在合并两者时，只会简单地把指针右移，因为这种单线的历史分支不存在任何需要解决的分歧，所以这种合并过程可以称为快进（ Fast forward ）。比如：\u000D\u000A![file]( https://static.lufficc.com/image/e7a07a13d694f40a5fd6049ba689d953.png)\u000D\u000A***注意箭头方向，因为每一次提交都有一个指向上一次提交的指针，所以箭头方向向左，更为合理***\u000D\u000A\u000D\u000A当在`master`分支合并`dev`分支时，因为他们在一条线上，这种单线的历史分支不存在任何需要解决的分歧，所以只需要`master`分支指向`dev`分支即可，所以非常快。\u000D\u000A\u000D\u000A当分支出现分叉时，就有可能出现冲突，而这时 Git 就会要求你去解决冲突，比如像下面的历史：\u000D\u000A![file]( https://static.lufficc.com/image/d44cf799898ccdd6ccd19afe18b58a77.png)\u000D\u000A因为`master`分支和`dev`分支不在一条线上，即`v7`不是`v5`的直接祖先， Git 不得不进行一些额外处理。就此例而言， Git 会用两个分支的末端（`v7` 和 `v5`）以及它们的共同祖先（`v3`）进行一次简单的三方合并计算。合并之后会生成一个和并提交`v8`：\u000D\u000A![file]( https://static.lufficc.com/image/f6bccfbc3393ec3fe2549bb747310b81.png)\u000D\u000A注意：和并提交有两个祖先（`v7`和`v5`）。\u000D\u000A\u000D\u000A#### 分支的变基`rebase`\u000D\u000A把一个分支中的修改整合到另一个分支的办法有两种：`merge` 和 `rebase`。首先`merge` 和 `rebase`最终的结果是一样的，但 `rebase`能产生一个更为整洁的提交历史。仍然以上图为例，如果简单的`merge`，会生成一个提交对象`v8`，现在我们尝试使用变基合并分支，切换到`dev`：\u000D\u000A```\u000D\u000A$ git checkout dev\u000D\u000A$ git rebase master\u000D\u000AFirst, rewinding head to replay your work on top of it...\u000D\u000AApplying: added staged command\u000D\u000A```\u000D\u000A![file]( https://static.lufficc.com/image/d44cf799898ccdd6ccd19afe18b58a77.png)\u000D\u000A\u000D\u000A这段代码的意思是：回到两个分支最近的共同祖先`v3`，根据当前分支（也就是要进行变基的分支 `dev`）后续的历次提交对象（包括`v4`，`v5`），生成一系列文件补丁，然后以基底分支（也就是主干分支 `master`）最后一个提交对象（`v7`）为新的出发点，逐个应用之前准备好的补丁文件，最后会生成一个新的合并提交对象（`v7\u0027`）,从而改写 `dev` 的提交历史，使它成为 master 分支的直接下游，如下图：\u000D\u000A![file]( https://static.lufficc.com/image/6c5608fce70f583533064614439adf35.png)\u000D\u000A现在，就可以回到`master`分支进行快速合并 Fast\u002Dforward 了，因为`master`分支和`dev`分支在一条线上：\u000D\u000A```\u000D\u000A$ git checkout master\u000D\u000A$ git merge dev\u000D\u000A```\u000D\u000A![file]( https://static.lufficc.com/image/12f99d8e61265482f0f5d50d8576a97b.png)\u000D\u000A现在的` v7\u0027 `对应的快照，其实和普通的三方合并，即上个例子中的 `v8` 对应的快照内容一模一样。虽然最后整合得到的结果没有任何区别，但变基能产生一个更为整洁的提交历史。如果视察一个变基过的分支的历史记录，看起来会更清楚：仿佛所有修改都是在一根线上先后进行的，尽管实际上它们原本是同时并行发生的。\u000D\u000A\u000D\u000A## 总结\u000D\u000A\u002D\u002D\u002D\u002D\u002D\u002D\u002D\u002D\u002D\u002D\u002D\u002D\u002D\u002D\u002D\u000D\u000A1. Git 保存文件的完整内容，不保存差量变化。\u000D\u000A2. Git 以储键值对（`key\u002Dvalue`）的方式保存文件。\u000D\u000A3. 每一个文件，相同文件的不同版本，都有一个唯一的 40 位的 SHA\u002D1 校验和与之对应。\u000D\u000A4. SHA\u002D1 校验和是文件的指针， Git 依靠它来区分文件。\u000D\u000A5. 每一个文件都会在 Git 的版本库里生成`blob`对象来保存。\u000D\u000A6. 对于没有变化的文件， Git 只会保留上一个版本的指针。\u000D\u000A7. Git 实际上是通过维持复杂的文件树来实现版本控制的。\u000D\u000A8. 使用 Git 的工作流程基本就是就是文件在三个工作区域之间的流动。\u000D\u000A9. 应该大量使用分支进行团队协作。\u000D\u000A10. 分支只是对提交对象的一个引用。",
        "content_rendered" : "\u003Cp\u003E\u003Ca href\u003D\u0022https://lufficc.com/blog/the\u002Dcore\u002Dconception\u002Dof\u002Dgit\u0022 rel\u003D\u0022nofollow\u0022\u003E原文地址\u003C/a\u003E\u003C/p\u003E\u000A\u003Cblockquote\u003E\u000A\u003Cp\u003E文章内容来自自己的理解 和 \u003Ca href\u003D\u0022https://git\u002Dscm.com/book/en/v2\u0022 rel\u003D\u0022nofollow\u0022\u003Ehttps://git\u002Dscm.com/book/en/v2\u003C/a\u003E 。转载必须注明出处。\u003C/p\u003E\u000A\u003C/blockquote\u003E\u000A\u003Cp\u003E\u003Cstrong\u003E本文不是 Git 使用教学篇，而是偏向理论方面，旨在更加深刻的理解 Git ，这样才能更好的使用它，让工具成为我们得力的助手。\u003C/strong\u003E\u003C/p\u003E\u000A\u003Ch2\u003E版本控制系统\u003C/h2\u003E\u000A\u003Chr\u003E\u000A\u003Cp\u003EGit 是目前世界上最优秀的分布式版本控制系统。版本控制系统是能够随着时间的推进记录一系列文件的变化以便于你以后想要的退回到某个版本的系统。版本控制系统分为三大类：本地版本控制系统，集中式版本控制系统和分布式版本控制系统\u003C/p\u003E\u000A\u003Cp\u003E本地版本控制（ Local Version Control Systems ）是将文件的各个版本以一定的数据格式存储在本地的磁盘（有的 VCS 是保存文件的变化补丁，即在文件内容变化时计算出差量保存起来），这种方式在一定程度上解决了手动复制粘贴的问题，但无法解决多人协作的问题。\u003C/p\u003E\u000A\u003Cp\u003E本地版本控制\u000A\u003Cimg alt\u003D\u0022file\u0022 src\u003D\u0022https://static.lufficc.com/image/cd558122189f264c90636f46c5b97bce.png\u0022\u003E\u003C/p\u003E\u000A\u003Cp\u003E集中式版本控制（ Centralized Version Control Systems ）相比本地版本控制没有什么本质的变化，只是多了个一个中央服务器，各个版本的数据库存储在中央服务器，管理员可以控制开发人员的权限，而开发人员也可以从中央服务器拉取数据。集中式版本控制虽然解决了团队协作问题，但缺点也很明显：所有数据存储在中央服务器，服务器一旦宕机或者磁盘损坏，会造成不可估量的损失。\u003C/p\u003E\u000A\u003Cp\u003E集中式版本控制\u000A\u003Cimg alt\u003D\u0022file\u0022 src\u003D\u0022https://static.lufficc.com/image/150909dba84d774ff367e96633bb3a90.png\u0022\u003E\u003C/p\u003E\u000A\u003Cp\u003E分布式版本控制（ Distributed Version Control System ）与前两者均不同。首先，在分布式版本控制系统中，像 Git ， Mercurial ， Bazaar 以及 Darcs 等，系统保存的的不是文件变化的差量，而是文件的快照，即把文件的整体复制下来保存，而不关心具体的变化内容。其次，最重要的是分布式版本控制系统是分布式的，当你从中央服务器拷贝下来代码时，你拷贝的是一个完整的版本库，包括历史纪录，提交记录等，这样即使某一台机器宕机也能找到文件的完整备份。\u003C/p\u003E\u000A\u003Cp\u003E分布式版本控制\u000A\u003Cimg alt\u003D\u0022file\u0022 src\u003D\u0022https://static.lufficc.com/image/8b98633e172b406026a6b18127160928.png\u0022\u003E\u003C/p\u003E\u000A\u003Ch2\u003EGit 基础\u003C/h2\u003E\u000A\u003Chr\u003E\u000A\u003Cp\u003EGit 是一个分布式版本控制系统，保存的是文件的完整快照，而不是差异变化或者文件补丁。\u003C/p\u003E\u000A\u003Cp\u003E保存每一次变化文件的完整内容\u000A\u003Cimg alt\u003D\u0022file\u0022 src\u003D\u0022https://static.lufficc.com/image/a25948ea6ad62bc5f32c0f3473a26a82.png\u0022\u003E\u003C/p\u003E\u000A\u003Cp\u003EGit 每一次提交都是对项目文件的一个完整拷贝，因此你可以完全恢复到以前的任一个提交而不会发生任何区别。这里有一个问题：如果我的项目大小是 10M ，那 Git 占用的空间是不是随着提交次数的增加线性增加呢？我提交（ commit ）了 10 次，占用空间是不是 100M 呢？很显然不是， Git 是很智能的，如果文件没有变化，它只会保存一个指向上一个版本的文件的\u003Ccode\u003E指针\u003C/code\u003E，即，对于一个特定版本的文件， Git 只会保存一个副本，但可以有多个指向该文件的\u003Ccode\u003E指针\u003C/code\u003E。\u003C/p\u003E\u000A\u003Cp\u003E未变化的文件只保存上一个版本的指针\u000A\u003Cimg alt\u003D\u0022file\u0022 src\u003D\u0022https://static.lufficc.com/image/6ea58fd87fb479921752c3780c042f28.png\u0022\u003E\u003C/p\u003E\u000A\u003Cp\u003EGit 工程有三个工作区域：工作目录，暂存区域，以及本地仓库。工作目录是你当前进行工作的区域；暂存区域是你运行\u003Ccode\u003Egit add\u003C/code\u003E命令后文件保存的区域，也是下次提交将要保存的文件（注意： Git 提交实际读取的是暂存区域的内容，而与工作区域的文件无关，这也是当你修改了文件之后，如果没有添加\u003Ccode\u003Egit add\u003C/code\u003E到暂存区域，并不会保存到版本库的原因）；本地仓库就是版本库，记录了你工程某次提交的完整状态和内容，这意味着你的数据永远不会丢失。\u000A\u003Cimg alt\u003D\u0022file\u0022 src\u003D\u0022https://static.lufficc.com/image/c27143ae881ce36f097ba89bbacae972.png\u0022\u003E\u000A相应的，文件也有三种状态：已提交（ committed ），已修改（ modified ）和已暂存（ staged ）。已提交表示该文件已经被安全地保存在本地版本库中了；已修改表示修改了某个文件，但还没有提交保存；已暂存表示把已修改的文件放在下次提交时要保存的清单中，即暂存区域。所以使用 Git 的基本工作流程就是：\u003C/p\u003E\u000A\u003Col\u003E\u000A\u003Cli\u003E在工作区域增加，删除或者修改文件。\u003C/li\u003E\u000A\u003Cli\u003E运行\u003Ccode\u003Egit add\u003C/code\u003E，将文件快照保存到暂存区域。\u003C/li\u003E\u000A\u003Cli\u003E提交更新，将文件永久版保存到版本库中。\u000A\u003Cimg alt\u003D\u0022file\u0022 src\u003D\u0022https://static.lufficc.com/image/c8e38594228844c944ec68fcb82b9152.png\u0022\u003E\u003C/li\u003E\u000A\u003C/ol\u003E\u000A\u003Ch2\u003EGit 对象\u003C/h2\u003E\u000A\u003Chr\u003E\u000A\u003Cp\u003E现在已经明白 Git 的基本流程，但 Git 是怎么完成的呢？ Git 怎么区分文件是否发生变化？下面简单介绍一下 Git 的基本原理。\u003C/p\u003E\u000A\u003Ch4\u003ESHA\u002D1 校验和\u003C/h4\u003E\u000A\u003Cp\u003EGit 是一套内容寻址文件系统。意思就是 Git 从核心上来看不过是简单地存储键值对（\u003Ccode\u003Ekey\u002Dvalue\u003C/code\u003E），\u003Ccode\u003Evalue\u003C/code\u003E是文件的内容，而\u003Ccode\u003Ekey\u003C/code\u003E是文件内容与文件头信息的 40 个字符长度的 SHA\u002D1 校验和，例如：\u003Ccode\u003E5453545dccd33565a585ffe5f53fda3e067b84d8\u003C/code\u003E。 Git 使用该校验和不是为了加密，而是为了数据的完整性，它可以保证，在很多年后，你重新 checkout 某个 commit 时，一定是它多年前的当时的状态，完全一摸一样。当你对文件进行了哪怕一丁点儿的修改，也会计算出完全不同的 SHA\u002D1 校验和，这种现象叫做“雪崩效应”（ Avalanche effect ）。\u003C/p\u003E\u000A\u003Cp\u003ESHA\u002D1 校验和因此就是上文提到的文件的\u003Ccode\u003E指针\u003C/code\u003E，这和 C 语言中的\u003Ccode\u003E指针\u003C/code\u003E很有些不同： C 语言将数据在内存中的地址作为\u003Ccode\u003E指针\u003C/code\u003E， Git 将文件的 SHA\u002D1 校验和作为\u003Ccode\u003E指针\u003C/code\u003E，目的都是为了唯一区分不同的对象。但是当 C 语言\u003Ccode\u003E指针\u003C/code\u003E指向的内存中的内容发生变化时，\u003Ccode\u003E指针\u003C/code\u003E并不发生变化，但 Git\u003Ccode\u003E指针\u003C/code\u003E指向的文件内容发生变化时，\u003Ccode\u003E指针\u003C/code\u003E也会发生变化。所以， Git 中每一个版本的文件，都有一个唯一的\u003Ccode\u003E指针\u003C/code\u003E指向它。\u003C/p\u003E\u000A\u003Ch4\u003E文件(blob)对象，树(tree)对象，提交(commit)对象\u003C/h4\u003E\u000A\u003Cp\u003E\u003Ccode\u003Eblob\u003C/code\u003E 对象保存的仅仅是文件的内容，\u003Ccode\u003Etree\u003C/code\u003E 对象更像是操作系统中的文件夹，它可以保存\u003Ccode\u003Eblob\u003C/code\u003E对象和\u003Ccode\u003Etree\u003C/code\u003E 对象。一个单独的 \u003Ccode\u003Etree\u003C/code\u003E 对象包含一条或多条 \u003Ccode\u003Etree\u003C/code\u003E 记录，每一条记录含有一个指向 \u003Ccode\u003Eblob\u003C/code\u003E 对象或子 \u003Ccode\u003Etree\u003C/code\u003E 对象的 SHA\u002D1 指针，并附有该对象的权限模式 (mode)、类型和文件名信息等：\u000A\u003Cimg alt\u003D\u0022file\u0022 src\u003D\u0022https://static.lufficc.com/image/8f108375134643622b7e9273520eed91.png\u0022\u003E\u000A当你对文件进行修改并提交时，变化的文件会生成一个新的\u003Ccode\u003Eblob\u003C/code\u003E对象，记录文件的完整内容（是全部内容，不是变化内容），然后针对该文件有一个唯一的 SHA\u002D1 校验和，修改此次提交该文件的\u003Ccode\u003E指针\u003C/code\u003E为该 SHA\u002D1 校验和，而对于没有变化的文件，简单拷贝上一次版本的\u003Ccode\u003E指针\u003C/code\u003E即 SHA\u002D1 校验和，而不会生成一个全新的\u003Ccode\u003Eblob\u003C/code\u003E对象，这也解释了 10M 大小的项目进行 10 次提交总大小远远小于 100M 的原因。\u003C/p\u003E\u000A\u003Cp\u003E另外，每次提交可能不仅仅只有一个 \u003Ccode\u003Etree\u003C/code\u003E 对象，它们指明了项目的不同快照，但你必须记住所有对象的 SHA\u002D1 校验和才能获得完整的快照，而且没有作者，何时，为什么保存这些快照的原因。\u003Ccode\u003Ecommit\u003C/code\u003E对象就是问了解决这些问题诞生的，\u003Ccode\u003Ecommit\u003C/code\u003E 对象的格式很简单：指明了该时间点项目快照的顶层\u003Ccode\u003Etree\u003C/code\u003E对象、作者 /提交者信息（从 Git 设置的 \u003Ca href\u003D\u0022http://user.name\u0022 rel\u003D\u0022nofollow\u0022\u003Euser.name\u003C/a\u003E 和 user.email 中获得)以及当前时间戳、一个空行，上一次的提交对象的 ID 以及提交注释信息。你可以简单的运行\u003Ccode\u003Egit log\u003C/code\u003E来获取这新信息：\u003C/p\u003E\u000A\u003Cpre\u003E\u003Ccode\u003E$ git log\u000Acommit 2cb0bb475c34a48957d18f67d0623e3304a26489\u000AAuthor: lufficc \u0026lt\u003Bluffy.lcc@gmail.com\u0026gt\u003B\u000ADate:   Sun Oct 2 17:29:30 2016 +0800\u000A\u000A    fix some font size\u000A\u000Acommit f0c8b4b31735b5e5e96e456f9b0c8d5fc7a3e68a\u000AAuthor: lufficc \u0026lt\u003Bluffy.lcc@gmail.com\u0026gt\u003B\u000ADate:   Sat Oct 1 02:55:48 2016 +0800\u000A\u000A    fix post show css\u000A\u000A***********省略***********\u000A\u003C/code\u003E\u003C/pre\u003E\u000A\u003Cp\u003E\u003Cimg alt\u003D\u0022file\u0022 src\u003D\u0022https://static.lufficc.com/image/092c08d87d63ff0a804356705ce01c4b.png\u0022\u003E\u000A上图的 Test.txt 是第一次提交之前生成的，第一次它的初始 SHA\u002D1 校验和以\u003Ccode\u003E3c4e9c\u003C/code\u003E开头。随后对它进行了修改，所以第二次提交时生成了一个全新\u003Ccode\u003Eblob\u003C/code\u003E对象，校验和以\u003Ccode\u003E1f7a7a\u003C/code\u003E开头。而第三次提交时 Test.txt 并没有变化，所以只是保存最近版本的 SHA\u002D1 校验和而不生成全新的\u003Ccode\u003Eblob\u003C/code\u003E对象。在项目开发过程中新增加的文件在提交后都会生成一个全新的\u003Ccode\u003Eblob\u003C/code\u003E对象来保存它。\u003Cstrong\u003E注意除了第一次每个提交对象都有一个指向上一次提交对象的指针\u003C/strong\u003E。\u003C/p\u003E\u000A\u003Cp\u003E因此简单来说，\u003Ccode\u003Eblob\u003C/code\u003E对象保存文件的内容；\u003Ccode\u003Etree\u003C/code\u003E对象类似文件夹，保存\u003Ccode\u003Eblob\u003C/code\u003E对象和其它\u003Ccode\u003Etree\u003C/code\u003E对象；\u003Ccode\u003Ecommit\u003C/code\u003E对象保存\u003Ccode\u003Etree\u003C/code\u003E对象，提交信息，作者，邮箱以及上一次的提交对象的 ID （第一次提交没有）。而 Git 就是通过组织和管理这些对象的状态以及复杂的关系实现的版本控制以及以及其他功能如分支。\u003C/p\u003E\u000A\u003Ch2\u003EGit 引用\u003C/h2\u003E\u000A\u003Chr\u003E\u000A\u003Cp\u003E现在再来看引用，就会很简单了。如果我们想要看某个提交记录之前的完整历史，就必须记住这个提交 ID ，但提交 ID 是一个 40 位的 SHA\u002D1 校验和，难记。所以引用就是 SHA\u002D1 校验和的别名，存储在\u003Ccode\u003E.git/refs\u003C/code\u003E文件夹中。\u003C/p\u003E\u000A\u003Cp\u003E最常见的引用也许就是\u003Ccode\u003Emaster\u003C/code\u003E了，因为这是 Git 默认创建的（可以修改，但一般不修改），它始终指向你项目主分支的最后最后一次提交记录。如果在项目根目录运行\u003Ccode\u003Ecat .git/refs/heads\u003C/code\u003E，会输出一个 SHA\u002D1 校验和，例如：\u003C/p\u003E\u000A\u003Cpre\u003E\u003Ccode\u003E$ cat .git/refs/heads/master\u000A4f3e6a6f8c62bde818b4b3d12c8cf3af45d6dc00\u000A\u003C/code\u003E\u003C/pre\u003E\u000A\u003Cp\u003E因此\u003Ccode\u003Emaster\u003C/code\u003E只是一个 40 位 SHA\u002D1 校验和的别名罢了。\u003C/p\u003E\u000A\u003Cp\u003E还有一个问题， Git 如何知道你当前分支的最后一次的提交 ID?在\u003Ccode\u003E.git\u003C/code\u003E文件夹下有一个\u003Ccode\u003EHEAD\u003C/code\u003E文件，像这样：\u003C/p\u003E\u000A\u003Cpre\u003E\u003Ccode\u003E$ cat .git/HEAD\u000Aref: refs/heads/master\u000A\u003C/code\u003E\u003C/pre\u003E\u000A\u003Cp\u003E\u003Ccode\u003EHEAD\u003C/code\u003E文件其实并不包含 SHA\u002D1 值，而是一个指向当前分支的引用，内容会随着切换分支而变化，内容格式像这样：\u003Ccode\u003Eref: refs/heads/\u0026lt\u003Bbranch\u002Dname\u0026gt\u003B\u003C/code\u003E。当你执行\u003Ccode\u003Egit commit\u003C/code\u003E命令时，它就创建了一个\u003Ccode\u003Ecommit\u003C/code\u003E对象，把这个\u003Ccode\u003Ecommit\u003C/code\u003E对象的父级设置为 \u003Ccode\u003EHEAD\u003C/code\u003E 指向的引用的 SHA\u002D1 值。\u003C/p\u003E\u000A\u003Cp\u003E再来说说 Git 的 tag ，标签。标签从某种意义上像是一个引用， 它指向一个 \u003Ccode\u003Ecommit\u003C/code\u003E 对象而不是一个 \u003Ccode\u003Etree\u003C/code\u003E，包含一个标签，一组数据，一个消息和一个\u003Ccode\u003Ecommit\u003C/code\u003E 对象的指针。但是区别就是引用随着项目进行它的值在不断向前推进变化，但是标签不会变化——永远指向同一个 \u003Ccode\u003Ecommit\u003C/code\u003E，仅仅是提供一个更加友好的名字。\u003C/p\u003E\u000A\u003Ch2\u003EGit 分支\u003C/h2\u003E\u000A\u003Chr\u003E\u000A\u003Ch4\u003E分支\u003C/h4\u003E\u000A\u003Cp\u003E分支是 Git 的杀手级特征，而且 Git 鼓励在工作流程中频繁使用分支与合并，哪怕一天之内进行许多次都没有关系。因为 Git 分支非常轻量级，不像其他的版本控制，创建分支意味着要把项目完整的拷贝一份，而 Git 创建分支是在瞬间完成的，而与你工程的复杂程度无关。\u003C/p\u003E\u000A\u003Cp\u003E因为在上文中已经说到， Git 保存文件的最基本的对象是\u003Ccode\u003Eblob\u003C/code\u003E对象， Git 本质上只是一棵巨大的文件树，树的每一个节点就是\u003Ccode\u003Eblob\u003C/code\u003E对象，而分支只是树的一个分叉。说白了，分支就是一个有名字的引用，它包含一个提交对象的的 40 位校验和，所以创建分支就是向一个文件写入 41 个字节（外加一个换行符）那么简单，所以自然就快了，而且与项目的复杂程度无关。\u003C/p\u003E\u000A\u003Cp\u003EGit 的默认分支是 master ，存储在\u003Ccode\u003E.git\u005Crefs\u005Cheads\u005Cmaster\u003C/code\u003E文件中，假设你在 master 分支运行\u003Ccode\u003Egit branch dev\u003C/code\u003E创建了一个名字为\u003Ccode\u003Edev\u003C/code\u003E的分支，那么 git 所做的实际操作是：\u003C/p\u003E\u000A\u003Col\u003E\u000A\u003Cli\u003E在\u003Ccode\u003E.git\u005Crefs\u005Cheads\u003C/code\u003E文件夹下新建一个文件名为\u003Ccode\u003Edev\u003C/code\u003E（没有扩展名）的文本文件。\u003C/li\u003E\u000A\u003Cli\u003E将 HEAD 指向的当前分支（当前为\u003Ccode\u003Emaster\u003C/code\u003E）的 40 位 SHA\u002D1 校验和外加一个换行符写入\u003Ccode\u003Edev\u003C/code\u003E文件。\u003C/li\u003E\u000A\u003Cli\u003E结束。\u003C/li\u003E\u000A\u003C/ol\u003E\u000A\u003Cp\u003E\u003Cimg alt\u003D\u0022file\u0022 src\u003D\u0022https://static.lufficc.com/image/f6ae8c281b6e8a17f11b2807a97c5109.png\u0022\u003E\u003C/p\u003E\u000A\u003Cp\u003E创建分支就是这么简单，那么切换分支呢？更简单：\u003C/p\u003E\u000A\u003Col\u003E\u000A\u003Cli\u003E修改\u003Ccode\u003E.git\u003C/code\u003E文件下的\u003Ccode\u003EHEAD\u003C/code\u003E文件为\u003Ccode\u003Eref: refs/heads/\u0026lt\u003B分支名称\u0026gt\u003B\u003C/code\u003E。\u003C/li\u003E\u000A\u003Cli\u003E按照分支指向的提交记录将工作区的文件恢复至一模一样。\u003C/li\u003E\u000A\u003Cli\u003E结束。\u003C/li\u003E\u000A\u003C/ol\u003E\u000A\u003Cp\u003E记住，\u003Ccode\u003EHEAD\u003C/code\u003E文件指向当前分支的最后一次提交，同时，它也是以当前分支再次创建一个分支时，将要写入的内容。\u003C/p\u003E\u000A\u003Ch4\u003E分支合并\u003C/h4\u003E\u000A\u003Cp\u003E再来说一说合并，首先是 Fast\u002Dforward ，换句话说，如果顺着一个分支走下去可以到达另一个分支的话，那么 Git 在合并两者时，只会简单地把指针右移，因为这种单线的历史分支不存在任何需要解决的分歧，所以这种合并过程可以称为快进（ Fast forward ）。比如：\u000A\u003Cimg alt\u003D\u0022file\u0022 src\u003D\u0022https://static.lufficc.com/image/e7a07a13d694f40a5fd6049ba689d953.png\u0022\u003E\u000A\u003Cstrong\u003E\u003Cem\u003E注意箭头方向，因为每一次提交都有一个指向上一次提交的指针，所以箭头方向向左，更为合理\u003C/em\u003E\u003C/strong\u003E\u003C/p\u003E\u000A\u003Cp\u003E当在\u003Ccode\u003Emaster\u003C/code\u003E分支合并\u003Ccode\u003Edev\u003C/code\u003E分支时，因为他们在一条线上，这种单线的历史分支不存在任何需要解决的分歧，所以只需要\u003Ccode\u003Emaster\u003C/code\u003E分支指向\u003Ccode\u003Edev\u003C/code\u003E分支即可，所以非常快。\u003C/p\u003E\u000A\u003Cp\u003E当分支出现分叉时，就有可能出现冲突，而这时 Git 就会要求你去解决冲突，比如像下面的历史：\u000A\u003Cimg alt\u003D\u0022file\u0022 src\u003D\u0022https://static.lufficc.com/image/d44cf799898ccdd6ccd19afe18b58a77.png\u0022\u003E\u000A因为\u003Ccode\u003Emaster\u003C/code\u003E分支和\u003Ccode\u003Edev\u003C/code\u003E分支不在一条线上，即\u003Ccode\u003Ev7\u003C/code\u003E不是\u003Ccode\u003Ev5\u003C/code\u003E的直接祖先， Git 不得不进行一些额外处理。就此例而言， Git 会用两个分支的末端（\u003Ccode\u003Ev7\u003C/code\u003E 和 \u003Ccode\u003Ev5\u003C/code\u003E）以及它们的共同祖先（\u003Ccode\u003Ev3\u003C/code\u003E）进行一次简单的三方合并计算。合并之后会生成一个和并提交\u003Ccode\u003Ev8\u003C/code\u003E：\u000A\u003Cimg alt\u003D\u0022file\u0022 src\u003D\u0022https://static.lufficc.com/image/f6bccfbc3393ec3fe2549bb747310b81.png\u0022\u003E\u000A注意：和并提交有两个祖先（\u003Ccode\u003Ev7\u003C/code\u003E和\u003Ccode\u003Ev5\u003C/code\u003E）。\u003C/p\u003E\u000A\u003Ch4\u003E分支的变基\u003Ccode\u003Erebase\u003C/code\u003E\u003C/h4\u003E\u000A\u003Cp\u003E把一个分支中的修改整合到另一个分支的办法有两种：\u003Ccode\u003Emerge\u003C/code\u003E 和 \u003Ccode\u003Erebase\u003C/code\u003E。首先\u003Ccode\u003Emerge\u003C/code\u003E 和 \u003Ccode\u003Erebase\u003C/code\u003E最终的结果是一样的，但 \u003Ccode\u003Erebase\u003C/code\u003E能产生一个更为整洁的提交历史。仍然以上图为例，如果简单的\u003Ccode\u003Emerge\u003C/code\u003E，会生成一个提交对象\u003Ccode\u003Ev8\u003C/code\u003E，现在我们尝试使用变基合并分支，切换到\u003Ccode\u003Edev\u003C/code\u003E：\u003C/p\u003E\u000A\u003Cpre\u003E\u003Ccode\u003E$ git checkout dev\u000A$ git rebase master\u000AFirst, rewinding head to replay your work on top of it...\u000AApplying: added staged command\u000A\u003C/code\u003E\u003C/pre\u003E\u000A\u003Cp\u003E\u003Cimg alt\u003D\u0022file\u0022 src\u003D\u0022https://static.lufficc.com/image/d44cf799898ccdd6ccd19afe18b58a77.png\u0022\u003E\u003C/p\u003E\u000A\u003Cp\u003E这段代码的意思是：回到两个分支最近的共同祖先\u003Ccode\u003Ev3\u003C/code\u003E，根据当前分支（也就是要进行变基的分支 \u003Ccode\u003Edev\u003C/code\u003E）后续的历次提交对象（包括\u003Ccode\u003Ev4\u003C/code\u003E，\u003Ccode\u003Ev5\u003C/code\u003E），生成一系列文件补丁，然后以基底分支（也就是主干分支 \u003Ccode\u003Emaster\u003C/code\u003E）最后一个提交对象（\u003Ccode\u003Ev7\u003C/code\u003E）为新的出发点，逐个应用之前准备好的补丁文件，最后会生成一个新的合并提交对象（\u003Ccode\u003Ev7\u0027\u003C/code\u003E）,从而改写 \u003Ccode\u003Edev\u003C/code\u003E 的提交历史，使它成为 master 分支的直接下游，如下图：\u000A\u003Cimg alt\u003D\u0022file\u0022 src\u003D\u0022https://static.lufficc.com/image/6c5608fce70f583533064614439adf35.png\u0022\u003E\u000A现在，就可以回到\u003Ccode\u003Emaster\u003C/code\u003E分支进行快速合并 Fast\u002Dforward 了，因为\u003Ccode\u003Emaster\u003C/code\u003E分支和\u003Ccode\u003Edev\u003C/code\u003E分支在一条线上：\u003C/p\u003E\u000A\u003Cpre\u003E\u003Ccode\u003E$ git checkout master\u000A$ git merge dev\u000A\u003C/code\u003E\u003C/pre\u003E\u000A\u003Cp\u003E\u003Cimg alt\u003D\u0022file\u0022 src\u003D\u0022https://static.lufficc.com/image/12f99d8e61265482f0f5d50d8576a97b.png\u0022\u003E\u000A现在的\u003Ccode\u003Ev7\u0027\u003C/code\u003E对应的快照，其实和普通的三方合并，即上个例子中的 \u003Ccode\u003Ev8\u003C/code\u003E 对应的快照内容一模一样。虽然最后整合得到的结果没有任何区别，但变基能产生一个更为整洁的提交历史。如果视察一个变基过的分支的历史记录，看起来会更清楚：仿佛所有修改都是在一根线上先后进行的，尽管实际上它们原本是同时并行发生的。\u003C/p\u003E\u000A\u003Ch2\u003E总结\u003C/h2\u003E\u000A\u003Chr\u003E\u000A\u003Col\u003E\u000A\u003Cli\u003EGit 保存文件的完整内容，不保存差量变化。\u003C/li\u003E\u000A\u003Cli\u003EGit 以储键值对（\u003Ccode\u003Ekey\u002Dvalue\u003C/code\u003E）的方式保存文件。\u003C/li\u003E\u000A\u003Cli\u003E每一个文件，相同文件的不同版本，都有一个唯一的 40 位的 SHA\u002D1 校验和与之对应。\u003C/li\u003E\u000A\u003Cli\u003ESHA\u002D1 校验和是文件的指针， Git 依靠它来区分文件。\u003C/li\u003E\u000A\u003Cli\u003E每一个文件都会在 Git 的版本库里生成\u003Ccode\u003Eblob\u003C/code\u003E对象来保存。\u003C/li\u003E\u000A\u003Cli\u003E对于没有变化的文件， Git 只会保留上一个版本的指针。\u003C/li\u003E\u000A\u003Cli\u003EGit 实际上是通过维持复杂的文件树来实现版本控制的。\u003C/li\u003E\u000A\u003Cli\u003E使用 Git 的工作流程基本就是就是文件在三个工作区域之间的流动。\u003C/li\u003E\u000A\u003Cli\u003E应该大量使用分支进行团队协作。\u003C/li\u003E\u000A\u003Cli\u003E分支只是对提交对象的一个引用。\u003C/li\u003E\u000A\u003C/ol\u003E\u000A",
        "replies" : 30,
        "member" : {
            "id" : 187138,
            "username" : "luffylcc",
            "tagline" : "",
            "avatar_mini" : "//cdn.v2ex.co/avatar/6bdb/372d/187138_mini.png?m=1474476132",
            "avatar_normal" : "//cdn.v2ex.co/avatar/6bdb/372d/187138_normal.png?m=1474476132",
            "avatar_large" : "//cdn.v2ex.co/avatar/6bdb/372d/187138_large.png?m=1474476132"
        },
        "node" : {
            "id" : 300,
            "name" : "programmer",
            "title" : "程序员",
            "title_alternative" : "Programmer",
            "url" : "http://www.v2ex.com/go/programmer",
            "topics" : 13380,
            "avatar_mini" : "//cdn.v2ex.co/navatar/94f6/d7e0/300_mini.png?m=1475028013",
            "avatar_normal" : "//cdn.v2ex.co/navatar/94f6/d7e0/300_normal.png?m=1475028013",
            "avatar_large" : "//cdn.v2ex.co/navatar/94f6/d7e0/300_large.png?m=1475028013"
        },
        "created" : 1475501387,
        "last_modified" : 1475501438,
        "last_touched" : 1475554329
    }
    
]